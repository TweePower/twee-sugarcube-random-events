// repository: https://github.com/TweePower/twee-sugarcube-random-events

const debugLevel = 3; // max debug level

(function () {
    'use strict';

    /*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var RandomEventAppExport;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ConstraintsVerificator.ts":
/*!***************************************!*\
  !*** ./src/ConstraintsVerificator.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ConstraintsVerificator)\n/* harmony export */ });\n/* harmony import */ var _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DebugLogCollector */ \"./src/DebugLogCollector.ts\");\n/* harmony import */ var _tools_TypeChecker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tools/TypeChecker */ \"./src/tools/TypeChecker.ts\");\n\n\nclass ConstraintsVerificator {\n    constructor(sugarcubeFacade, tagsManager, randomEventStats) {\n        this.sugarcubeFacade = sugarcubeFacade;\n        this.tagsManager = tagsManager;\n        this.randomEventStats = randomEventStats;\n    }\n    verify(randomEvent, compiledTags, rewriteConfiguration) {\n        var _a, _b, _c;\n        let result = true;\n        let usedLimitationStrategyTags = [];\n        const debugLogCollector = new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        if (rewriteConfiguration.isValidateIsEnable === false) {\n            debugLogCollector.addLog(true, 'skip IsEnable verify', 2);\n        }\n        else {\n            const checkResult = this.verifyIsEnable((_a = rewriteConfiguration.isEnabled) !== null && _a !== void 0 ? _a : randomEvent.isEnabled);\n            result = checkResult.result;\n            debugLogCollector\n                .addLog(checkResult.result, `verify IsEnable using: ${rewriteConfiguration.isEnabled ? 'rewrite configuration' : 'passage metadata'}`, 2)\n                .increaseLevel()\n                .merge(checkResult.debugLogCollector)\n                .decreaseLevel();\n        }\n        if (result) {\n            if (rewriteConfiguration.isValidateFilter === false) {\n                debugLogCollector.addLog(true, 'skip filter verify', 2);\n            }\n            else {\n                const checkResult = this.verifyFilter((_b = rewriteConfiguration.filter) !== null && _b !== void 0 ? _b : randomEvent.filter);\n                result = checkResult.result;\n                debugLogCollector\n                    .addLog(checkResult.result, `verify filter using: ${rewriteConfiguration.filter ? 'rewrite configuration' : 'passage metadata'}`, 2)\n                    .increaseLevel()\n                    .merge(checkResult.debugLogCollector)\n                    .decreaseLevel();\n            }\n        }\n        if (result) {\n            let checkResult;\n            if (randomEvent._isLimitationStrategiesTagged) {\n                checkResult = this.verifyTaggedLimitationStrategy(randomEvent.passageName, randomEvent.limitationStrategies, compiledTags);\n            }\n            else {\n                checkResult = this.verifyNotTaggedLimitationStrategy(randomEvent.passageName, randomEvent.limitationStrategies, compiledTags);\n            }\n            result = checkResult.result;\n            debugLogCollector\n                .addLog(checkResult.result, `verify limitationStrategies using: 'passage metadata'`, 2)\n                .increaseLevel()\n                .merge(checkResult.debugLogCollector)\n                .decreaseLevel();\n            usedLimitationStrategyTags = checkResult.additionalData.usedLimitationStrategyTags;\n        }\n        if (result) {\n            if (rewriteConfiguration.isValidateThreshold === false) {\n                debugLogCollector.addLog(true, 'skip threshold verify', 2);\n            }\n            else {\n                const checkResult = this.verifyThreshold((_c = rewriteConfiguration.threshold) !== null && _c !== void 0 ? _c : randomEvent.threshold);\n                result = checkResult.result;\n                debugLogCollector\n                    .addLog(checkResult.result, `verify threshold using: ${rewriteConfiguration.threshold ? 'rewrite configuration' : 'passage metadata'}`, 2).increaseLevel()\n                    .merge(checkResult.debugLogCollector)\n                    .decreaseLevel();\n            }\n        }\n        return {\n            result,\n            debugLogCollector,\n            additionalData: {\n                usedLimitationStrategyTags\n            }\n        };\n    }\n    verifyIsEnable(isEnabled) {\n        const result = isEnabled;\n        return {\n            result,\n            debugLogCollector: new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().addLog(result, result ? 'event enabled' : 'event disabled', 3)\n        };\n    }\n    verifyFilter(filter) {\n        if (filter === true || filter === false) {\n            return {\n                result: filter,\n                debugLogCollector: new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().addLog(filter, `filter expression returns ${filter ? 'true' : 'false'}`, 3)\n            };\n        }\n        let result;\n        try {\n            result = this.sugarcubeFacade.runTeweeScript(filter);\n        }\n        catch (error) {\n            error.message = \"bad evaluation: \" + error.message;\n            throw error;\n        }\n        if (result !== true && result !== false) {\n            throw new Error(`invalid filter expression return type (expected: boolean: actual: ${typeof result})`);\n        }\n        return {\n            result,\n            debugLogCollector: new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().addLog(result, `filter expression returns ${result ? 'true' : 'false'}`, 3)\n        };\n    }\n    verifyTaggedLimitationStrategy(passageName, limitationStrategies, compiledTags) {\n        const debugLogCollector = new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        const usedLimitationStrategyTags = [];\n        let isSuccess = true;\n        if (limitationStrategies.length <= 0) {\n            return {\n                result: true,\n                debugLogCollector: new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](),\n                additionalData: {\n                    usedLimitationStrategyTags: []\n                },\n            };\n        }\n        limitationStrategies.forEach(limitationStrategy => {\n            // skip all next if already found limitation which is not passed\n            if (isSuccess === false) {\n                return;\n            }\n            if (limitationStrategy.max <= 0) {\n                debugLogCollector.addLog(true, 'limitationStrategy max value <= 0', 3);\n                return;\n            }\n            if (limitationStrategy.tags.length > 0) {\n                const limitationStrategyTags = [...this.tagsManager.prepareTags(limitationStrategy.tags)];\n                // skip checking limitationStrategy when current compiled tags have not included `limitation.tags`\n                for (let i = 0; i < limitationStrategyTags.length; i++) {\n                    if (!compiledTags.includes(limitationStrategyTags[i])) {\n                        debugLogCollector\n                            .addLog(false, `tag '${limitationStrategyTags[i]}' not found in current tags`, 3)\n                            .increaseLevel()\n                            .increaseLevel()\n                            .addLog(null, `current tags   : ${compiledTags.join(', ')}`, 3)\n                            .addLog(null, `limitation tags: ${limitationStrategyTags.join(', ')}`, 3)\n                            .decreaseLevel()\n                            .decreaseLevel();\n                        return;\n                    }\n                }\n                const fullLimitationStrategyTags = [\n                    ...limitationStrategyTags,\n                    ...(limitationStrategy.isSeparate ? [passageName] : [])\n                ];\n                const fullLimitationStrategyTagsKey = this.tagsManager.convertTagsToStringKey(fullLimitationStrategyTags);\n                const actualFiredTagCount = this.randomEventStats.getTagRunCountActual(fullLimitationStrategyTagsKey);\n                if (actualFiredTagCount >= limitationStrategy.max) {\n                    isSuccess = false;\n                    debugLogCollector.addLog(false, `limitationStrategy with tags ['${limitationStrategyTags.join(', ')}'] have max value ${limitationStrategy.max} but already fired ${actualFiredTagCount} times`, 3);\n                    return;\n                }\n                else {\n                    usedLimitationStrategyTags.push(fullLimitationStrategyTags);\n                    debugLogCollector.addLog(true, `limitationStrategy with tags ['${limitationStrategyTags.join(', ')}'] have max value ${limitationStrategy.max} and already fired ${actualFiredTagCount} times`, 3);\n                }\n            }\n            else {\n                const actualFiredEventCount = this.randomEventStats.getPassageRunCountActual(passageName);\n                if (actualFiredEventCount >= limitationStrategy.max) {\n                    isSuccess = false;\n                    debugLogCollector.addLog(false, `limitationStrategy without tags have max value ${limitationStrategy.max} but already fired ${actualFiredEventCount} times`, 3);\n                    return;\n                }\n                else {\n                    debugLogCollector.addLog(true, `limitationStrategy without tags have max value ${limitationStrategy.max} and already fired ${actualFiredEventCount} times`, 3);\n                }\n            }\n        });\n        if (isSuccess && usedLimitationStrategyTags.length <= 0) {\n            isSuccess = false;\n            debugLogCollector.addLog(false, `not found any limitationStrategy where current tags cover all limitationStrategy tags (current tags: ${compiledTags.join(', ')}`, 3);\n        }\n        return {\n            result: isSuccess,\n            debugLogCollector,\n            additionalData: { usedLimitationStrategyTags }\n        };\n    }\n    verifyNotTaggedLimitationStrategy(passageName, limitationStrategies, compiledTags) {\n        const debugLogCollector = new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        const usedLimitationStrategyTags = [];\n        let isSuccess = true;\n        if (limitationStrategies.length <= 0) {\n            return {\n                result: true,\n                debugLogCollector: new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](),\n                additionalData: {\n                    usedLimitationStrategyTags: []\n                },\n            };\n        }\n        limitationStrategies.forEach(limitationStrategy => {\n            if (limitationStrategy.max <= 0) {\n                debugLogCollector.addLog(true, 'limitationStrategy max value <= 0', 3);\n                return;\n            }\n            const actualFiredEventCount = this.randomEventStats.getPassageRunCountActual(passageName);\n            if (actualFiredEventCount >= limitationStrategy.max) {\n                isSuccess = false;\n                debugLogCollector.addLog(false, `random event have max value ${limitationStrategy.max} but already fired ${actualFiredEventCount} times`, 3);\n                return;\n            }\n            else {\n                debugLogCollector.addLog(true, `random event have max value ${limitationStrategy.max} and already fired ${actualFiredEventCount} times`, 3);\n            }\n        });\n        return {\n            result: isSuccess,\n            debugLogCollector,\n            additionalData: { usedLimitationStrategyTags }\n        };\n    }\n    verifyThreshold(threshold) {\n        let thresholdResult = 0;\n        if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_1__.isNumber)(threshold)) {\n            try {\n                thresholdResult = this.sugarcubeFacade.runTeweeScript(threshold.toString());\n            }\n            catch (error) {\n                error.message = \"bad evaluation: \" + error.message;\n                throw error;\n            }\n        }\n        else {\n            thresholdResult = threshold;\n        }\n        if (thresholdResult >= 100) {\n            return {\n                result: true,\n                debugLogCollector: new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().addLog(true, 'threshold is equal to or greater than 100', 3)\n            };\n        }\n        const randomValue = Math.floor(Math.random() * 100);\n        if (randomValue > thresholdResult) {\n            return {\n                result: false,\n                debugLogCollector: new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().addLog(false, `random value is greater than threshold (random=${randomValue} > threshold=${thresholdResult})`, 3)\n            };\n        }\n        return {\n            result: true,\n            debugLogCollector: new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().addLog(true, 'threshold passed (random=' + randomValue + ' <= threshold=' + thresholdResult + ')', 3)\n        };\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/ConstraintsVerificator.ts?");

/***/ }),

/***/ "./src/DebugLogCollector.ts":
/*!**********************************!*\
  !*** ./src/DebugLogCollector.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DebugLogCollector)\n/* harmony export */ });\nclass DebugLogCollector {\n    constructor(debugLevel = 0) {\n        this.debugLevel = debugLevel;\n        this.currentLevel = 0;\n        this.logs = [];\n        if (debugLevel !== 0 && debugLevel !== 1 && debugLevel !== 2 && debugLevel !== 3) {\n            throw new Error(\"Debug level should be 0, 1, 2 or 3\");\n        }\n    }\n    addLog(result, message, debugLevel, level) {\n        this.logs.push({\n            result: result,\n            message: message,\n            debugLevel: debugLevel,\n            level: level === undefined ? this.currentLevel : level,\n        });\n        return this;\n    }\n    merge(debugLogCollector) {\n        debugLogCollector.all().forEach(log => this.addLog(log.result, log.message, log.debugLevel, log.level + this.currentLevel));\n        return this;\n    }\n    increaseLevel() {\n        this.currentLevel++;\n        return this;\n    }\n    decreaseLevel() {\n        this.currentLevel--;\n        if (this.currentLevel < 0) {\n            this.currentLevel = 0;\n        }\n        return this;\n    }\n    get length() {\n        return this.logs.length;\n    }\n    all() {\n        return this.logs;\n    }\n    toString() {\n        return this.logs\n            .filter(log => log.debugLevel <= this.debugLevel)\n            .map(log => ('  '.repeat(log.level)) + (log.result === true ? '+ ' : (log.result === false ? '- ' : '')) + log.message)\n            .join(\"\\n\");\n    }\n    clear() {\n        this.currentLevel = 0;\n        this.logs = [];\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/DebugLogCollector.ts?");

/***/ }),

/***/ "./src/Lock.ts":
/*!*********************!*\
  !*** ./src/Lock.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Lock)\n/* harmony export */ });\nclass Lock {\n    constructor() {\n        this.lockData = {\n            isLocked: false,\n            isForce: false,\n        };\n    }\n    acquire() {\n        if (this.lockData.isForce === false) {\n            this.lockData.isLocked = true;\n        }\n    }\n    release() {\n        if (this.lockData.isForce === false) {\n            this.lockData.isLocked = false;\n        }\n    }\n    forceAcquire() {\n        this.lockData.isLocked = true;\n        this.lockData.isForce = true;\n    }\n    forceRelease() {\n        this.lockData.isLocked = false;\n        this.lockData.isForce = false;\n    }\n    get isLocked() {\n        return this.lockData.isLocked;\n    }\n    get isForce() {\n        return this.lockData.isForce;\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/Lock.ts?");

/***/ }),

/***/ "./src/RandomEventApp.ts":
/*!*******************************!*\
  !*** ./src/RandomEventApp.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RandomEventApp)\n/* harmony export */ });\n/* harmony import */ var _Lock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Lock */ \"./src/Lock.ts\");\n/* harmony import */ var _DebugLogCollector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DebugLogCollector */ \"./src/DebugLogCollector.ts\");\n/* harmony import */ var _ConstraintsVerificator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ConstraintsVerificator */ \"./src/ConstraintsVerificator.ts\");\n/* harmony import */ var _enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enum/GroupTypeEnum */ \"./src/enum/GroupTypeEnum.ts\");\n/* harmony import */ var _TagsManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TagsManager */ \"./src/TagsManager.ts\");\n/* harmony import */ var _error_PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./error/PassageMetadataValidationError */ \"./src/error/PassageMetadataValidationError.ts\");\n/* harmony import */ var _processors_RandomEventPassageMetadataProcessor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./processors/RandomEventPassageMetadataProcessor */ \"./src/processors/RandomEventPassageMetadataProcessor.ts\");\n/* harmony import */ var _tools_TypeChecker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tools/TypeChecker */ \"./src/tools/TypeChecker.ts\");\n/* harmony import */ var _macros_index__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./macros/index */ \"./src/macros/index.ts\");\n/* harmony import */ var _facade_SugarcubeFacade__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./facade/SugarcubeFacade */ \"./src/facade/SugarcubeFacade.ts\");\n/* harmony import */ var _RandomEventStats__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./RandomEventStats */ \"./src/RandomEventStats.ts\");\n\n\n\n\n\n\n\n\n\n\n\nclass RandomEventApp {\n    constructor(passageMetadataApp, debugLevel = 0) {\n        this.passageMetadataApp = passageMetadataApp;\n        this._passagesByTagIndex = {};\n        this._passagesByGroupIndex = {};\n        this.acquireLock = () => this.lock.acquire();\n        this.releaseLock = () => this.lock.release();\n        this.forceAcquireLock = () => this.lock.forceAcquire();\n        this.forceReleaseLock = () => this.lock.forceRelease();\n        this.has = (passageName) => this.passageMetadataApp.has(passageName);\n        this.find = (passageName) => this.passageMetadataApp.find(passageName);\n        this.sugarcubeFacade = new _facade_SugarcubeFacade__WEBPACK_IMPORTED_MODULE_9__[\"default\"]();\n        this.tagsManager = new _TagsManager__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.sugarcubeFacade);\n        this.lock = new _Lock__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        this.debugLogCollector = new _DebugLogCollector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](debugLevel);\n        this.randomEventStats = new _RandomEventStats__WEBPACK_IMPORTED_MODULE_10__[\"default\"](passageMetadataApp, this.tagsManager);\n        this.constraintsVerificator = new _ConstraintsVerificator__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.sugarcubeFacade, this.tagsManager, this.randomEventStats);\n        const randomEventPassageMetadataProcessor = new _processors_RandomEventPassageMetadataProcessor__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n        passageMetadataApp.onBeforeAddMetadata.add((passageMetadataObject) => {\n            try {\n                randomEventPassageMetadataProcessor.process(passageMetadataObject);\n            }\n            catch (error) {\n                if (error instanceof _error_PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_5__[\"default\"]) {\n                    let message = error.message;\n                    if (error.path.length > 0) {\n                        message += ' ';\n                        error.path.forEach((path, index) => {\n                            if (index === 0 || path[0] === '[') {\n                                message += path;\n                            }\n                            else {\n                                message += '.' + path;\n                            }\n                        });\n                    }\n                    let scopeMessage = [];\n                    if (error.expected !== null) {\n                        scopeMessage.push('expected ' + error.expected);\n                    }\n                    if (error.actual !== null) {\n                        scopeMessage.push('actual ' + error.actual);\n                    }\n                    throw new Error(`${message}${scopeMessage.join.length > 0 ? ` (${scopeMessage.join(', ')})` : ''}`);\n                }\n                throw error;\n            }\n        });\n        passageMetadataApp.onAfterAddMetadata.add((passageMetadata) => {\n            const data = passageMetadata.data;\n            if (data.tags.length > 0) {\n                data.tags.forEach((tag) => {\n                    if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_7__.isTweeScript)(tag)) {\n                        return;\n                    }\n                    if (this._passagesByTagIndex[tag] === undefined) {\n                        this._passagesByTagIndex[tag] = [];\n                    }\n                    this._passagesByTagIndex[tag].push(data.passageName);\n                });\n            }\n            if (data.groups.length > 0) {\n                data.groups.forEach((group) => {\n                    if (this._passagesByGroupIndex[group.name] === undefined) {\n                        this._passagesByGroupIndex[group.name] = [];\n                    }\n                    this._passagesByGroupIndex[group.name].push(data.passageName);\n                });\n            }\n        });\n        passageMetadataApp.onBeforeRestore.add((state) => {\n            const passageNames = Object.keys(state);\n            passageNames.forEach((passageName) => {\n                const data = state[passageName];\n                if (data.e !== undefined) {\n                    data.isEnabled = data.e;\n                    delete data.e;\n                }\n            });\n        });\n        passageMetadataApp.onBeforeStore.add((state) => {\n            const passageNames = Object.keys(state);\n            passageNames.forEach((passageName) => {\n                const data = state[passageName];\n                if (data.isEnabled !== undefined) {\n                    data.e = data.isEnabled;\n                    delete data.isEnabled;\n                }\n            });\n        });\n        (0,_macros_index__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this, passageMetadataApp, this.sugarcubeFacade);\n    }\n    get isLocked() {\n        return this.lock.isLocked;\n    }\n    ;\n    get isForceLocked() {\n        return this.lock.isForce;\n    }\n    ;\n    enable(passageName) {\n        if (!this.passageMetadataApp.has(passageName)) {\n            if (!this.sugarcubeFacade.hasPassage(passageName)) {\n                throw new Error(`passage \"${passageName}\" does not exist`);\n            }\n            if (this.passageMetadataApp.mode === 'byTag') {\n                throw new Error(`passage \"${passageName}\" exist but without tag \"${this.passageMetadataApp.modeParams.filterTag}\"`);\n            }\n            else {\n                throw new Error(`passage \"${passageName}\" does'n contain metadata`);\n            }\n        }\n        this.passageMetadataApp.get(passageName).setValue('isEnabled', true);\n        this.passageMetadataApp.storeState();\n    }\n    disable(passageName) {\n        if (!this.passageMetadataApp.has(passageName)) {\n            if (!this.sugarcubeFacade.hasPassage(passageName)) {\n                throw new Error(`passage \"${passageName}\" does not exist`);\n            }\n            if (this.passageMetadataApp.mode === 'byTag') {\n                throw new Error(`passage \"${passageName}\" exist but without tag \"${this.passageMetadataApp.modeParams.filterTag}\"`);\n            }\n            else {\n                throw new Error(`passage \"${passageName}\" does'n contain metadata`);\n            }\n        }\n        this.passageMetadataApp.get(passageName).setValue('isEnabled', false);\n        this.passageMetadataApp.storeState();\n    }\n    enableByTag(tag) {\n        if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_7__.isArray)(this._passagesByTagIndex[tag])) {\n            this._passagesByTagIndex[tag].forEach((passageName) => {\n                const passageMetadata = this.passageMetadataApp.get(passageName);\n                passageMetadata.setValue('isEnabled', true);\n            });\n            this.passageMetadataApp.storeState();\n        }\n    }\n    disableByTag(tag) {\n        if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_7__.isArray)(this._passagesByTagIndex[tag])) {\n            this._passagesByTagIndex[tag].forEach((passageName) => {\n                const passageMetadata = this.passageMetadataApp.get(passageName);\n                passageMetadata.setValue('isEnabled', false);\n            });\n            this.passageMetadataApp.storeState();\n        }\n    }\n    runRandomEvent(passageName, rewriteConfiguration) {\n        this.debugLogCollector.clear();\n        rewriteConfiguration = {\n            ...{\n                isValidateIsEnable: true,\n                isEnabled: null,\n                isValidateFilter: true,\n                filter: null,\n                isValidateLimitationStrategy: true,\n                limitationStrategy: null,\n                isValidateThreshold: true,\n                threshold: null,\n            },\n            ...(rewriteConfiguration !== null && rewriteConfiguration !== void 0 ? rewriteConfiguration : {})\n        };\n        if (!this.passageMetadataApp.has(passageName)) {\n            if (!this.sugarcubeFacade.hasPassage(passageName)) {\n                throw new Error(`passage \"${passageName}\" does not exist`);\n            }\n            throw new Error(`passage \"${passageName}\" exist but without tag \"${this.passageMetadataApp.modeParams.filterTag}\"`);\n        }\n        const passageMetadata = (this.passageMetadataApp.get(passageName)).data;\n        this.debugLogCollector.addLog(null, `Start random event ${passageMetadata.passageName}`, 1);\n        this.debugLogCollector.increaseLevel();\n        let result = true;\n        if (this.lock.isLocked) {\n            result = false;\n            this.debugLogCollector.addLog(null, `Skip because lock already acquired`, 1);\n            return {\n                isSuccess: result,\n                debugLogCollector: this.debugLogCollector,\n                passageMetadata,\n                usedTags: []\n            };\n        }\n        try {\n            const compiledTags = this.tagsManager.prepareTags(passageMetadata.tags);\n            const checkResult = this.constraintsVerificator.verify(passageMetadata, compiledTags, rewriteConfiguration);\n            this.debugLogCollector\n                .addLog(null, `Verify:`, 2)\n                .increaseLevel()\n                .merge(checkResult.debugLogCollector)\n                .decreaseLevel();\n            return {\n                isSuccess: checkResult.result,\n                debugLogCollector: this.debugLogCollector,\n                passageMetadata,\n                usedTags: passageMetadata._isLimitationStrategiesTagged ? checkResult.additionalData.usedLimitationStrategyTags : [compiledTags]\n            };\n        }\n        catch (error) {\n            // TODO add data to error\n            throw error;\n        }\n    }\n    runGroup(groupName, groupThreshold, rewriteConfiguration) {\n        this.debugLogCollector.clear();\n        rewriteConfiguration = {\n            ...{\n                isValidateIsEnable: true,\n                isEnable: null,\n                isValidateFilter: true,\n                filter: null,\n                isValidateLimitationStrategy: true,\n                limitationStrategy: null,\n                isValidateThreshold: true,\n                threshold: null,\n            },\n            ...(rewriteConfiguration !== null && rewriteConfiguration !== void 0 ? rewriteConfiguration : {})\n        };\n        if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_7__.isArray)(this._passagesByGroupIndex[groupName])) {\n            throw new Error(`group \"${groupName}\" does not exist`);\n        }\n        this.debugLogCollector.addLog(null, `Start group ${groupName}`, 1);\n        this.debugLogCollector.increaseLevel();\n        let result = true;\n        if (this.lock.isLocked) {\n            result = false;\n            this.debugLogCollector.addLog(null, `Skip because lock already acquired`, 1);\n            return {\n                isSuccess: result,\n                debugLogCollector: this.debugLogCollector,\n            };\n        }\n        if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_7__.isNumber)(groupThreshold) || (0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_7__.isString)(groupThreshold)) {\n            try {\n                const checkResult = this.constraintsVerificator.verifyThreshold(groupThreshold);\n                result = checkResult.result;\n                this.debugLogCollector\n                    .addLog(null, 'Verify group threshold', 2)\n                    .increaseLevel()\n                    .merge(checkResult.debugLogCollector)\n                    .decreaseLevel();\n            }\n            catch (error) {\n                // TODO add data to error\n                throw error;\n            }\n            if (result === false) {\n                return {\n                    isSuccess: result,\n                    debugLogCollector: this.debugLogCollector,\n                };\n            }\n            rewriteConfiguration.isValidateThreshold = false;\n        }\n        this.debugLogCollector\n            .increaseLevel()\n            .addLog(null, 'Verify random events in group', 1)\n            .increaseLevel();\n        let totalWeight = 0;\n        const sucessRandomEventsResults = [];\n        for (let groupIndex = 0; groupIndex < this._passagesByGroupIndex[groupName].length; groupIndex++) {\n            const passageName = this._passagesByGroupIndex[groupName][groupIndex];\n            const passageMetadata = (this.passageMetadataApp.get(passageName)).data;\n            const group = passageMetadata.groups[passageMetadata._groupByNameIndex[groupName]];\n            this.debugLogCollector\n                .addLog(null, `Random event ${passageMetadata.passageName} with weight ${group.weight}`, 1)\n                .increaseLevel();\n            try {\n                const compiledTags = this.tagsManager.prepareTags(passageMetadata.tags);\n                const checkResult = this.constraintsVerificator.verify(passageMetadata, compiledTags, rewriteConfiguration);\n                const result = checkResult.result;\n                this.debugLogCollector\n                    .addLog(null, `Verify`, 2)\n                    .increaseLevel()\n                    .merge(checkResult.debugLogCollector)\n                    .decreaseLevel();\n                if (result) {\n                    totalWeight += group.weight;\n                    sucessRandomEventsResults.push({\n                        isSuccess: result,\n                        passageMetadata: passageMetadata,\n                        usedTags: passageMetadata._isLimitationStrategiesTagged ? checkResult.additionalData.usedLimitationStrategyTags : [compiledTags],\n                        group: group,\n                    });\n                }\n            }\n            catch (error) {\n                // TODO add data to error\n                throw error;\n            }\n            this.debugLogCollector.decreaseLevel();\n        }\n        if (sucessRandomEventsResults.length <= 0) {\n            result = false;\n            this.debugLogCollector.addLog(false, `not found any suitable random events in group`, 2);\n            return {\n                isSuccess: result,\n                debugLogCollector: this.debugLogCollector,\n            };\n        }\n        let winnerRandomEventResult = null;\n        if (sucessRandomEventsResults[0].group.type === _enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_3__.GroupTypeEnum.Sequential) {\n            this.debugLogCollector\n                .addLog(true, `Find winner event`, 2)\n                .increaseLevel();\n            const sucessRandomEventsSequentialResults = sucessRandomEventsResults.filter((sucessRandomEventsResult) => {\n                return this.randomEventStats.getPassageRunCountHistory(sucessRandomEventsResult.passageMetadata.passageName) < sucessRandomEventsResult.group.sequentialCount;\n            });\n            this.debugLogCollector.addLog(true, `sequential search found ${sucessRandomEventsSequentialResults.length} siutable events`, 3);\n            if (sucessRandomEventsSequentialResults.length > 0) {\n                winnerRandomEventResult = sucessRandomEventsSequentialResults.sort((a, b) => {\n                    return a.group.sequentialIndex - b.group.sequentialIndex;\n                })[0];\n                this.debugLogCollector.addLog(true, `winner random event: ${winnerRandomEventResult.passageMetadata.passageName}`, 3);\n                return {\n                    isSuccess: result,\n                    debugLogCollector: this.debugLogCollector,\n                    passageMetadata: winnerRandomEventResult.passageMetadata,\n                    usedTags: winnerRandomEventResult.usedTags,\n                    group: winnerRandomEventResult.group,\n                };\n            }\n        }\n        let winnerWeight = Math.floor(Math.random() * totalWeight);\n        this.debugLogCollector.addLog(true, `total weight: ${totalWeight} | wittner weight: ${winnerWeight}`, 3);\n        for (let i = 0; i < sucessRandomEventsResults.length; i++) {\n            winnerWeight -= sucessRandomEventsResults[i].group.weight;\n            if (winnerWeight <= 0) {\n                winnerRandomEventResult = sucessRandomEventsResults[i];\n                break;\n            }\n        }\n        this.debugLogCollector.addLog(true, `winner random event: ${winnerRandomEventResult.passageMetadata.passageName}`, 3);\n        return {\n            isSuccess: result,\n            debugLogCollector: this.debugLogCollector,\n            passageMetadata: winnerRandomEventResult.passageMetadata,\n            usedTags: winnerRandomEventResult.usedTags,\n            group: winnerRandomEventResult.group,\n        };\n    }\n    incrementRunCounters(passageName, usedTags) {\n        this.randomEventStats.incrementPassageRunCount(passageName);\n        this.randomEventStats.incrementTagsRunCount(passageName, usedTags);\n        this.passageMetadataApp.storeState();\n    }\n    resetRunCounterByPassage(passageName) {\n        this.randomEventStats.resetPassageRunCount(passageName);\n        this.passageMetadataApp.storeState();\n    }\n    resetRunCounterByTag(tag) {\n        this.randomEventStats.resetTagsRunCount(tag);\n        this.passageMetadataApp.storeState();\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/RandomEventApp.ts?");

/***/ }),

/***/ "./src/RandomEventStats.ts":
/*!*********************************!*\
  !*** ./src/RandomEventStats.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RandomEventStats)\n/* harmony export */ });\n/* harmony import */ var _tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools/TypeChecker */ \"./src/tools/TypeChecker.ts\");\n\nclass RandomEventStats {\n    constructor(passageMetadataApp, tagsManager) {\n        this.passageMetadataApp = passageMetadataApp;\n        this.tagsManager = tagsManager;\n        this.passagesRunCountHistory = {};\n        this.passagesRunCountActual = {};\n        this.tagsRunCountHistory = {};\n        this.tagsRunCountActual = {};\n        this._passagesByTagIndex = {};\n        this._tagsStringKeysByPassageAndTagIndex = {};\n        this._tagsStringKeysIndex = {};\n        passageMetadataApp.onAfterAddMetadata.add((passageMetadata) => {\n            const data = passageMetadata.data;\n            data._stringTags.forEach((tag) => {\n                if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isString)(tag) || tag.length <= 0) {\n                    return;\n                }\n                if (this._passagesByTagIndex[tag] === undefined) {\n                    this._passagesByTagIndex[tag] = [];\n                }\n                this._passagesByTagIndex[tag].push(data.passageName);\n            });\n            data.limitationStrategies.forEach((limitationStrategy) => {\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isArray)(limitationStrategy.tags) && limitationStrategy.tags.length > 0) {\n                    const tags = limitationStrategy.tags;\n                    if (limitationStrategy.isSeparate === true) {\n                        tags.push(data.passageName);\n                    }\n                    const tagsStringKey = this.tagsManager.convertTagsToStringKey(tags);\n                    if (this._tagsStringKeysIndex[tagsStringKey] === undefined) {\n                        this._tagsStringKeysIndex[tagsStringKey] = [];\n                    }\n                    if (limitationStrategy.isSeparate === true) {\n                        tags.push(data.passageName);\n                    }\n                    limitationStrategy.tags.forEach((tag) => {\n                        if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isString)(tag) || tag.length <= 0) {\n                            return;\n                        }\n                        if (this._passagesByTagIndex[tag] === undefined) {\n                            this._passagesByTagIndex[tag] = [];\n                        }\n                        if (!this._passagesByTagIndex[tag].includes(passageMetadata.passageName)) {\n                            this._passagesByTagIndex[tag].push(passageMetadata.passageName);\n                        }\n                        if (this._tagsStringKeysByPassageAndTagIndex[tag] === undefined) {\n                            this._tagsStringKeysByPassageAndTagIndex[tag] = {};\n                        }\n                        if (this._tagsStringKeysByPassageAndTagIndex[tag][data.passageName] === undefined) {\n                            this._tagsStringKeysByPassageAndTagIndex[tag][data.passageName] = [];\n                        }\n                        this._tagsStringKeysByPassageAndTagIndex[tag][data.passageName].push(tagsStringKey);\n                        if (!this._tagsStringKeysIndex[tagsStringKey].includes(tag)) {\n                            this._tagsStringKeysIndex[tagsStringKey].push(tag);\n                        }\n                    });\n                }\n            });\n        });\n        passageMetadataApp.onBeforeRestore.add((state) => {\n            console.log(state);\n            const tagsIndex = {};\n            if (state.__tags !== undefined) {\n                state.__tags.forEach((tag, index) => {\n                    tagsIndex[index] = tag;\n                });\n                delete state.__tags;\n            }\n            this.passagesRunCountHistory = {};\n            this.passagesRunCountActual = {};\n            this.tagsRunCountHistory = {};\n            this.tagsRunCountActual = {};\n            const passageNames = Object.keys(state);\n            passageNames.forEach((passageName) => {\n                var _a, _b;\n                const data = state[passageName];\n                if (data._runCountActual === undefined) {\n                    data._runCountActual = 0;\n                }\n                if (data._runCountHistory === undefined) {\n                    data._runCountHistory = 0;\n                }\n                if (data._runCountByTagsActual === undefined) {\n                    data._runCountByTagsActual = {};\n                }\n                if (data._runCountByTagsHistory === undefined) {\n                    data._runCountByTagsHistory = {};\n                }\n                if (data.s !== undefined) {\n                    data._runCountActual = (_a = data.s.a) !== null && _a !== void 0 ? _a : data._runCountActual;\n                    data._runCountHistory = (_b = data.s.h) !== null && _b !== void 0 ? _b : data._runCountHistory;\n                    if (data.s.t !== undefined) {\n                        const tagsIndexes = Object.keys(data.s.t).map((index) => parseInt(index));\n                        tagsIndexes.forEach((tagIndex) => {\n                            if (data.s.t[tagIndex].a !== undefined) {\n                                data._runCountByTagsActual[tagsIndex[tagIndex]] = data.s.t[tagIndex].a;\n                            }\n                            if (data.s.t[tagIndex].h !== undefined) {\n                                data._runCountByTagsHistory[tagsIndex[tagIndex]] = data.s.t[tagIndex].h;\n                            }\n                        });\n                    }\n                    delete data.s;\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isNumber)(data._runCountActual)) {\n                    this.passagesRunCountActual[passageName] = data._runCountActual;\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isNumber)(data._runCountHistory)) {\n                    this.passagesRunCountHistory[passageName] = data._runCountHistory;\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isObject)(data._runCountByTagsActual)) {\n                    const tags = Object.keys(data._runCountByTagsActual);\n                    tags.forEach((tag) => {\n                        if (this.tagsRunCountActual[tag] === undefined) {\n                            this.tagsRunCountActual[tag] = 0;\n                        }\n                        this.tagsRunCountActual[tag] += data._runCountByTagsActual[tag];\n                    });\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isObject)(data._runCountByTagsHistory)) {\n                    const tags = Object.keys(data._runCountByTagsHistory);\n                    tags.forEach((tag) => {\n                        if (this.tagsRunCountHistory[tag] === undefined) {\n                            this.tagsRunCountHistory[tag] = 0;\n                        }\n                        this.tagsRunCountHistory[tag] += data._runCountByTagsHistory[tag];\n                    });\n                }\n            });\n        });\n        passageMetadataApp.onBeforeStore.add((state) => {\n            let tagsIndexLength = 0;\n            const tagsIndex = {};\n            const passageNames = Object.keys(state);\n            passageNames.forEach((passageName) => {\n                const data = state[passageName];\n                const optimizedStats = {};\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isNumber)(data._runCountActual)) {\n                    optimizedStats.a = data._runCountActual;\n                    delete data._runCountActual;\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isNumber)(data._runCountHistory)) {\n                    optimizedStats.h = data._runCountHistory;\n                    delete data._runCountHistory;\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isObject)(data._runCountByTagsActual)) {\n                    const tags = Object.keys(data._runCountByTagsActual);\n                    if (tags.length > 0) {\n                        optimizedStats.t = {};\n                        tags.forEach((tag) => {\n                            if (tagsIndex[tag] === undefined) {\n                                tagsIndex[tag] = tagsIndexLength;\n                                tagsIndexLength++;\n                            }\n                            if (optimizedStats.t[tagsIndex[tag]] === undefined) {\n                                optimizedStats.t[tagsIndex[tag]] = {};\n                            }\n                            optimizedStats.t[tagsIndex[tag]].a = data._runCountByTagsActual[tag];\n                        });\n                    }\n                    delete data._runCountByTagsActual;\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isObject)(data._runCountByTagsHistory)) {\n                    const tags = Object.keys(data._runCountByTagsHistory);\n                    if (tags.length > 0) {\n                        if (optimizedStats.t === undefined) {\n                            optimizedStats.t = {};\n                        }\n                        tags.forEach((tag) => {\n                            if (tagsIndex[tag] === undefined) {\n                                tagsIndex[tag] = tagsIndexLength;\n                                tagsIndexLength++;\n                            }\n                            if (optimizedStats.t[tagsIndex[tag]] === undefined) {\n                                optimizedStats.t[tagsIndex[tag]] = {};\n                            }\n                            optimizedStats.t[tagsIndex[tag]].h = data._runCountByTagsHistory[tag];\n                        });\n                    }\n                    delete data._runCountByTagsHistory;\n                }\n                if (Object.keys(optimizedStats).length > 0) {\n                    data.s = optimizedStats;\n                }\n            });\n            if (tagsIndexLength > 0) {\n                state.__tags = Object.keys(tagsIndex);\n            }\n        });\n    }\n    incrementPassageRunCount(passageName, count = 1, isStoreImmediately = false) {\n        const passageMetadata = this.passageMetadataApp.get(passageName);\n        const runCountHistory = passageMetadata.data._runCountHistory + count;\n        const runCountActual = passageMetadata.data._runCountActual + count;\n        passageMetadata.setValue('_runCountHistory', runCountHistory);\n        passageMetadata.setValue('_runCountActual', runCountActual);\n        this.passagesRunCountHistory[passageName] = runCountHistory;\n        this.passagesRunCountActual[passageName] = runCountActual;\n        if (isStoreImmediately === true) {\n            this.passageMetadataApp.storeState();\n        }\n    }\n    incrementTagsRunCount(passageName, tagsList, count = 1, isStoreImmediately = false) {\n        const passageMetadata = this.passageMetadataApp.get(passageName);\n        const currentRunCountByTagsHistory = passageMetadata.data._runCountByTagsHistory;\n        const currentRunCountByTagsActual = passageMetadata.data._runCountByTagsActual;\n        if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isArray)(tagsList) && tagsList.length > 0) {\n            tagsList.forEach(tags => {\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isArray)(tags) && tags.length > 0) {\n                    const uniqueTags = [...tags].filter((tag, index, array) => array.indexOf(tag) === index);\n                    const tagsStringKey = this.tagsManager.convertTagsToStringKey(tags);\n                    uniqueTags.forEach(tag => {\n                        if (tag !== '') {\n                            currentRunCountByTagsHistory[tag] = currentRunCountByTagsHistory[tag] === undefined ? count : currentRunCountByTagsHistory[tag] + count;\n                            currentRunCountByTagsActual[tag] = currentRunCountByTagsActual[tag] === undefined ? count : currentRunCountByTagsActual[tag] + count;\n                            this.tagsRunCountHistory[tag] = this.tagsRunCountHistory[tag] === undefined ? count : this.tagsRunCountHistory[tag] + count;\n                            this.tagsRunCountActual[tag] = this.tagsRunCountActual[tag] === undefined ? count : this.tagsRunCountActual[tag] + count;\n                        }\n                    });\n                    if (tagsStringKey !== '') {\n                        currentRunCountByTagsHistory[tagsStringKey] = currentRunCountByTagsHistory[tagsStringKey] === undefined ? count : currentRunCountByTagsHistory[tagsStringKey] + count;\n                        currentRunCountByTagsActual[tagsStringKey] = currentRunCountByTagsActual[tagsStringKey] === undefined ? count : currentRunCountByTagsActual[tagsStringKey] + count;\n                        this.tagsRunCountHistory[tagsStringKey] = this.tagsRunCountHistory[tagsStringKey] === undefined ? count : this.tagsRunCountHistory[tagsStringKey] + count;\n                        this.tagsRunCountActual[tagsStringKey] = this.tagsRunCountActual[tagsStringKey] === undefined ? count : this.tagsRunCountActual[tagsStringKey] + count;\n                    }\n                }\n            });\n        }\n        passageMetadata.setValue('_runCountByTagsHistory', currentRunCountByTagsHistory);\n        passageMetadata.setValue('_runCountByTagsActual', currentRunCountByTagsActual);\n        if (isStoreImmediately === true) {\n            this.passageMetadataApp.storeState();\n        }\n    }\n    resetPassageRunCount(passageName, isStoreImmediately = false) {\n        const passageMetadata = this.passageMetadataApp.get(passageName);\n        passageMetadata.setValue('_runCountActual', 0);\n        this.passagesRunCountActual[passageName] = 0;\n        if (isStoreImmediately === true) {\n            this.passageMetadataApp.storeState();\n        }\n    }\n    resetTagsRunCount(tags, isStoreImmediately = false) {\n        if (!Array.isArray(tags)) {\n            tags = [tags];\n        }\n        if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isArray)(tags)) {\n            tags.forEach((tag) => {\n                if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isString)(tag)) {\n                    throw new Error('Tag shouldb be string');\n                }\n                if (this.tagsRunCountActual[tag] !== undefined) {\n                    delete this.tagsRunCountActual[tag];\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isArray)(this._passagesByTagIndex[tag])) {\n                    this._passagesByTagIndex[tag].forEach((passageName) => {\n                        const passageMetadata = this.passageMetadataApp.get(passageName);\n                        passageMetadata.setValue('_runCountActual', 0);\n                        delete this.passagesRunCountActual[passageName];\n                        const runCountByTagsActual = { ...passageMetadata.data._runCountByTagsActual };\n                        delete runCountByTagsActual[tag];\n                        passageMetadata.setValue('_runCountByTagsActual', runCountByTagsActual);\n                    });\n                }\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isObject)(this._tagsStringKeysByPassageAndTagIndex[tag])) {\n                    const passageNames = Object.keys(this._tagsStringKeysByPassageAndTagIndex[tag]);\n                    passageNames.forEach((passageName) => {\n                        if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isArray)(this._tagsStringKeysByPassageAndTagIndex[tag][passageName])) {\n                            const passageMetadata = this.passageMetadataApp.get(passageName);\n                            this._tagsStringKeysByPassageAndTagIndex[tag][passageName].forEach((tagsStringKey) => {\n                                const runCountByTagsActual = { ...passageMetadata.data._runCountByTagsActual };\n                                if (runCountByTagsActual[tagsStringKey] !== undefined) {\n                                    if (this._tagsStringKeysIndex[tagsStringKey] !== undefined) {\n                                        this._tagsStringKeysIndex[tagsStringKey].forEach((tagFromTagsStringKey) => {\n                                            if (runCountByTagsActual[tagFromTagsStringKey] !== undefined) {\n                                                delete runCountByTagsActual[tagFromTagsStringKey];\n                                            }\n                                            if (this.tagsRunCountActual[tagFromTagsStringKey] !== undefined) {\n                                                delete this.tagsRunCountActual[tagFromTagsStringKey];\n                                            }\n                                        });\n                                    }\n                                    delete runCountByTagsActual[tagsStringKey];\n                                }\n                                passageMetadata.setValue('_runCountByTagsActual', runCountByTagsActual);\n                                if (this.tagsRunCountActual[tagsStringKey] !== undefined) {\n                                    delete this.tagsRunCountActual[tagsStringKey];\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        }\n        if (isStoreImmediately === true) {\n            this.passageMetadataApp.storeState();\n        }\n    }\n    getPassageRunCountActual(passageName) {\n        var _a;\n        return (_a = this.passagesRunCountActual[passageName]) !== null && _a !== void 0 ? _a : 0;\n    }\n    getPassageRunCountHistory(passageName) {\n        var _a;\n        return (_a = this.passagesRunCountHistory[passageName]) !== null && _a !== void 0 ? _a : 0;\n    }\n    getTagRunCountActual(tag) {\n        var _a;\n        return (_a = this.tagsRunCountActual[tag]) !== null && _a !== void 0 ? _a : 0;\n    }\n    getTagRunCountHistory(tag) {\n        var _a;\n        return (_a = this.tagsRunCountHistory[tag]) !== null && _a !== void 0 ? _a : 0;\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/RandomEventStats.ts?");

/***/ }),

/***/ "./src/TagsManager.ts":
/*!****************************!*\
  !*** ./src/TagsManager.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TagsManager)\n/* harmony export */ });\n/* harmony import */ var _tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools/TypeChecker */ \"./src/tools/TypeChecker.ts\");\n\nclass TagsManager {\n    constructor(sugarcubeFacade) {\n        this.sugarcubeFacade = sugarcubeFacade;\n    }\n    prepareTags(tags) {\n        return tags.map((tag) => {\n            if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_0__.isTweeScript)(tag)) {\n                return tag;\n            }\n            else {\n                try {\n                    return this.sugarcubeFacade.runTeweeScript(tag).trim().replace(' ', '__');\n                }\n                catch (error) {\n                    throw new Error(\"Invalid random event scripted tag: \" + tag);\n                }\n            }\n        }).sort();\n    }\n    convertTagsToStringKey(tags) {\n        return this.prepareTags(tags).join('_');\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/TagsManager.ts?");

/***/ }),

/***/ "./src/enum/GroupTypeEnum.ts":
/*!***********************************!*\
  !*** ./src/enum/GroupTypeEnum.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupTypeEnum: () => (/* binding */ GroupTypeEnum)\n/* harmony export */ });\nvar GroupTypeEnum;\n(function (GroupTypeEnum) {\n    GroupTypeEnum[\"Random\"] = \"random\";\n    GroupTypeEnum[\"Sequential\"] = \"sequential\";\n})(GroupTypeEnum || (GroupTypeEnum = {}));\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/enum/GroupTypeEnum.ts?");

/***/ }),

/***/ "./src/enum/Type.ts":
/*!**************************!*\
  !*** ./src/enum/Type.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypeEnum: () => (/* binding */ TypeEnum)\n/* harmony export */ });\nvar TypeEnum;\n(function (TypeEnum) {\n    TypeEnum[\"Embedded\"] = \"embedded\";\n    TypeEnum[\"Goto\"] = \"goto\";\n})(TypeEnum || (TypeEnum = {}));\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/enum/Type.ts?");

/***/ }),

/***/ "./src/error/InvalidPassageMetadataValue.ts":
/*!**************************************************!*\
  !*** ./src/error/InvalidPassageMetadataValue.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InvalidPassageMetadataValue)\n/* harmony export */ });\n/* harmony import */ var _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PassageMetadataValidationError */ \"./src/error/PassageMetadataValidationError.ts\");\n\nclass InvalidPassageMetadataValue extends _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(passageName = null, path = [], expected = null, actual = null) {\n        super('Invalid value', passageName, path, expected, actual);\n        Object.setPrototypeOf(this, _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype);\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/error/InvalidPassageMetadataValue.ts?");

/***/ }),

/***/ "./src/error/InvalidPassageMetadataValueType.ts":
/*!******************************************************!*\
  !*** ./src/error/InvalidPassageMetadataValueType.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ InvalidPassageMetadataValueType)\n/* harmony export */ });\n/* harmony import */ var _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PassageMetadataValidationError */ \"./src/error/PassageMetadataValidationError.ts\");\n\nclass InvalidPassageMetadataValueType extends _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(passageName = null, path = [], expected = null, actual = null) {\n        super('Invalid type', passageName, path, expected, actual);\n        Object.setPrototypeOf(this, _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype);\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/error/InvalidPassageMetadataValueType.ts?");

/***/ }),

/***/ "./src/error/PassageMetadataValidationError.ts":
/*!*****************************************************!*\
  !*** ./src/error/PassageMetadataValidationError.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PassageMetadataValidationError)\n/* harmony export */ });\nclass PassageMetadataValidationError extends Error {\n    constructor(message, passageName = null, path = [], expected = null, actual = null) {\n        super(message);\n        this._path = [];\n        this._expected = null;\n        this._actual = null;\n        this._passageName = passageName;\n        this._path = path;\n        this._expected = expected;\n        this._actual = actual;\n        Object.setPrototypeOf(this, PassageMetadataValidationError.prototype);\n    }\n    static fromPreviousError(previousError, passageName = null, path = []) {\n        path = [\n            ...path,\n            ...(previousError instanceof PassageMetadataValidationError) ? previousError.path : []\n        ];\n        passageName = passageName !== null ? passageName : (previousError instanceof PassageMetadataValidationError) ? previousError.passageName : null;\n        const error = new PassageMetadataValidationError(previousError.message, passageName, previousError instanceof PassageMetadataValidationError ? previousError.expected : null, previousError instanceof PassageMetadataValidationError ? previousError.actual : null);\n        error.stack = previousError.stack;\n        return error;\n    }\n    get passageName() {\n        return this._passageName;\n    }\n    get path() {\n        return this._path;\n    }\n    get expected() {\n        return this._expected;\n    }\n    get actual() {\n        return this._actual;\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/error/PassageMetadataValidationError.ts?");

/***/ }),

/***/ "./src/error/RequiredPassageMetadataValue.ts":
/*!***************************************************!*\
  !*** ./src/error/RequiredPassageMetadataValue.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RequiredPassageMetadataValue)\n/* harmony export */ });\n/* harmony import */ var _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PassageMetadataValidationError */ \"./src/error/PassageMetadataValidationError.ts\");\n\nclass RequiredPassageMetadataValue extends _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(condition, passageName = null, path = [], expected = null, actual = null) {\n        if (condition === null) {\n            super('Valie is required', passageName, path, expected, actual);\n        }\n        else {\n            super('Valie is required when ' + condition, passageName, path, expected, actual);\n        }\n        Object.setPrototypeOf(this, _PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype);\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/error/RequiredPassageMetadataValue.ts?");

/***/ }),

/***/ "./src/facade/SugarcubeFacade.ts":
/*!***************************************!*\
  !*** ./src/facade/SugarcubeFacade.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SugarcubeFacade)\n/* harmony export */ });\nclass SugarcubeFacade {\n    getAllPassages() {\n        return Story.lookup();\n    }\n    runTeweeScript(expression) {\n        return Scripting.evalJavaScript(Scripting.parse(expression));\n    }\n    getCurrentPassage() {\n        return passage();\n    }\n    hasPassage(passageName) {\n        return Story.has(passageName);\n    }\n    getVariable(name) {\n        return State.variables[name];\n    }\n    saveVariable(name, value) {\n        State.variables[name] = value;\n    }\n    addMacros(name, options) {\n        Macro.add(name, options);\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/facade/SugarcubeFacade.ts?");

/***/ }),

/***/ "./src/macros/index.ts":
/*!*****************************!*\
  !*** ./src/macros/index.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((randomEventApp, passageMetadataApp, sugarcubeFacade) => {\n    sugarcubeFacade.addMacros('REEnable', {\n        handler: function () {\n            if (this.args.length === 0) {\n                return this.error('No random event passage name specified');\n            }\n            var randomEventPassageName;\n            if (typeof this.args[0] === 'object') {\n                randomEventPassageName = this.args[0].link;\n            }\n            else {\n                randomEventPassageName = this.args[0];\n            }\n            try {\n                randomEventApp.enable(randomEventPassageName);\n            }\n            catch (err) {\n                this.error(err.message);\n            }\n        },\n    });\n    // TODO: Currently work only with 1 tag, will add possibility to pass multiply tags later\n    sugarcubeFacade.addMacros('REEnableByTag', {\n        handler: function () {\n            if (this.args.length !== 1) {\n                return this.error('Need to pass just 1 tag');\n            }\n            if (typeof this.args[0] !== 'string') {\n                return this.error('Random event tag should be a string value');\n            }\n            try {\n                randomEventApp.enableByTag(this.args[0]);\n            }\n            catch (err) {\n                this.error(err.message);\n            }\n        },\n    });\n    sugarcubeFacade.addMacros('REDisable', {\n        handler: function () {\n            if (this.args.length === 0) {\n                return this.error('No random event passage name specified');\n            }\n            var randomEventPassageName;\n            if (typeof this.args[0] === 'object') {\n                randomEventPassageName = this.args[0].link;\n            }\n            else {\n                randomEventPassageName = this.args[0];\n            }\n            try {\n                randomEventApp.disable(randomEventPassageName);\n            }\n            catch (err) {\n                this.error(err.message);\n            }\n        },\n    });\n    // TODO: Currently work only with 1 tag, will add possibility to pass multiply tags later\n    sugarcubeFacade.addMacros('REDisableByTag', {\n        handler: function () {\n            if (this.args.length !== 1) {\n                return this.error('Need to pass just 1 tag');\n            }\n            if (typeof this.args[0] !== 'string') {\n                return this.error('Random event tag should be a string value');\n            }\n            try {\n                randomEventApp.disableByTag(this.args[0]);\n            }\n            catch (err) {\n                this.error(err.message);\n            }\n        },\n    });\n    sugarcubeFacade.addMacros('REReset', {\n        handler: function () {\n            if (this.args.length === 0) {\n                return this.error('No random event passage name specified');\n            }\n            var randomEventPassageName;\n            if (typeof this.args[0] === 'object') {\n                randomEventPassageName = this.args[0].link;\n            }\n            else {\n                randomEventPassageName = this.args[0];\n            }\n            try {\n                randomEventApp.resetRunCounterByPassage(randomEventPassageName);\n            }\n            catch (err) {\n                this.error(err.message);\n            }\n        },\n    });\n    // TODO: Currently work only with 1 tag, will add possibility to pass multiply tags later\n    sugarcubeFacade.addMacros('REResetByTag', {\n        handler: function () {\n            if (this.args.length !== 1) {\n                return this.error('Need to pass just 1 tag');\n            }\n            if (typeof this.args[0] !== 'string') {\n                return this.error('Random event tag should be a string value');\n            }\n            try {\n                randomEventApp.resetRunCounterByTag(this.args[0]);\n            }\n            catch (err) {\n                this.error(err.message);\n            }\n        },\n    });\n    sugarcubeFacade.addMacros('RE', {\n        handler: function () {\n            if (this.args.length === 0) {\n                return this.error('No random event passage name specified');\n            }\n            var randomEventPassageName;\n            if (typeof this.args[0] === 'object') {\n                randomEventPassageName = this.args[0].link;\n            }\n            else {\n                randomEventPassageName = this.args[0];\n            }\n            try {\n                // TODO: maybe need to add more rewrite widget arguments\n                var result = randomEventApp.runRandomEvent(randomEventPassageName, {\n                    threshold: this.args[1]\n                });\n            }\n            catch (err) {\n                this.error(err.message);\n            }\n            if (Config.debug) {\n                var debugLog = '';\n                if (result.debugLogCollector.debugLevel > 0) {\n                    debugLog = result.debugLogCollector.toString();\n                }\n                this.debugView.name = 'RE \"' + result.passageMetadata.passageName + '\"';\n                this.debugView.title = debugLog;\n                this.debugView.modes({\n                    nonvoid: true,\n                    hidden: false,\n                    invalid: !result.isSuccess\n                });\n                if (result.debugLogCollector.debugLevel > 0) {\n                    console.log(debugLog);\n                }\n            }\n            // TODO remove this\n            if (result.debugLogCollector.debugLevel > 0) {\n                var debugLog = '';\n                debugLog += result.debugLogCollector.toString();\n                console.log(debugLog);\n            }\n            if (result.isSuccess) {\n                randomEventApp.incrementRunCounters(result.passageMetadata.passageName, result.usedTags);\n                if (result.passageMetadata.type === 'embedded') {\n                    var $el = jQuery(this.output);\n                    $el.wiki(Story.get(result.passageMetadata.passageName).processText());\n                }\n                else {\n                    randomEventApp.acquireLock();\n                    setTimeout(function () { Engine.play(result.passageMetadata.passageName, true), Engine.minDomActionDelay; });\n                }\n            }\n        },\n    });\n    sugarcubeFacade.addMacros('REGroup', {\n        handler: function () {\n            if (typeof this.args[0] !== 'string') {\n                return this.error('Random event group name should be a string value');\n            }\n            var groupName = this.args[0];\n            try {\n                // TODO: maybe need to add more arguments\n                var result = randomEventApp.runGroup(groupName, this.args[1]);\n            }\n            catch (err) {\n                this.error(err.message);\n            }\n            if (Config.debug) {\n                var debugLog = 'REGroup \"' + groupName + '\"';\n                if (result.debugLogCollector.debugLevel > 0) {\n                    debugLog = result.debugLogCollector.toString();\n                }\n                this.debugView.name = 'REGroup \"' + groupName + '\"';\n                this.debugView.title = debugLog;\n                this.debugView.modes({\n                    nonvoid: true,\n                    hidden: false,\n                    invalid: !result.isSuccess\n                });\n                if (result.debugLogCollector.debugLevel > 0) {\n                    console.log(debugLog);\n                }\n            }\n            // TODO remove this\n            if (result.debugLogCollector.debugLevel > 0) {\n                var debugLog = '';\n                debugLog += result.debugLogCollector.toString();\n                console.log(debugLog);\n            }\n            if (result.isSuccess) {\n                randomEventApp.incrementRunCounters(result.passageMetadata.passageName, result.usedTags);\n                if (result.passageMetadata.type === 'embedded') {\n                    var $el = jQuery(this.output);\n                    $el.wiki(Story.get(result.passageMetadata.passageName).processText());\n                }\n                else {\n                    randomEventApp.acquireLock();\n                    setTimeout(function () { Engine.play(result.passageMetadata.passageName, true), Engine.minDomActionDelay; });\n                }\n            }\n        },\n    });\n});\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/macros/index.ts?");

/***/ }),

/***/ "./src/processors/RandomEventPassageMetadataProcessor.ts":
/*!***************************************************************!*\
  !*** ./src/processors/RandomEventPassageMetadataProcessor.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RandomEventPassageMetadataProcessor)\n/* harmony export */ });\n/* harmony import */ var _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../error/InvalidPassageMetadataValueType */ \"./src/error/InvalidPassageMetadataValueType.ts\");\n/* harmony import */ var _error_InvalidPassageMetadataValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../error/InvalidPassageMetadataValue */ \"./src/error/InvalidPassageMetadataValue.ts\");\n/* harmony import */ var _tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/TypeChecker */ \"./src/tools/TypeChecker.ts\");\n/* harmony import */ var _error_PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../error/PassageMetadataValidationError */ \"./src/error/PassageMetadataValidationError.ts\");\n/* harmony import */ var _enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../enum/GroupTypeEnum */ \"./src/enum/GroupTypeEnum.ts\");\n/* harmony import */ var _error_RequiredPassageMetadataValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../error/RequiredPassageMetadataValue */ \"./src/error/RequiredPassageMetadataValue.ts\");\n/* harmony import */ var _enum_Type__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../enum/Type */ \"./src/enum/Type.ts\");\n\n\n\n\n\n\n\nclass RandomEventPassageMetadataProcessor {\n    // validate, normalize, enrich and build indexes for random event metadata\n    process(passageMetadataObject) {\n        if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isObject)(passageMetadataObject)) {\n            // we shouldn't be here, passage metadata previously checked in PassageMetadataCollector, I added that check just in case\n            throw new Error(`Invalid passage metadata type (expected JSON object, actual ${typeof passageMetadataObject})`);\n        }\n        if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.passageName)) {\n            // we shouldn't be here, passage name is always a string, I added that check just in case\n            throw new Error(`Invalid passage name type (expected string, actual ${typeof passageMetadataObject.passageName})`);\n        }\n        passageMetadataObject._isLimitationStrategiesTagged = false;\n        passageMetadataObject._groupByNameIndex = {};\n        passageMetadataObject._stringTags = [];\n        passageMetadataObject._runCountHistory = 0;\n        passageMetadataObject._runCountActual = 0;\n        passageMetadataObject._runCountByTagsHistory = {};\n        passageMetadataObject._runCountByTagsActual = {};\n        this.processIsEnabled(passageMetadataObject);\n        this.processGroups(passageMetadataObject);\n        this.processFilter(passageMetadataObject);\n        this.processType(passageMetadataObject);\n        this.processThreshold(passageMetadataObject);\n        this.processTags(passageMetadataObject);\n        this.processLimitationStrategies(passageMetadataObject);\n    }\n    processIsEnabled(passageMetadataObject) {\n        if (passageMetadataObject.isEnabled === undefined || passageMetadataObject.isEnabled === null) {\n            passageMetadataObject.isEnabled = true;\n        }\n        else if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(passageMetadataObject.isEnabled)) {\n            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'isEnabled'], 'boolean', typeof passageMetadataObject.isEnabled);\n        }\n    }\n    processGroups(passageMetadataObject) {\n        if (passageMetadataObject.groups === undefined || passageMetadataObject.groups === null) {\n            passageMetadataObject.groups = [];\n        }\n        else if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.groups) || (0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isObject)(passageMetadataObject.groups) || (0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isArray)(passageMetadataObject.groups)) {\n            if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.groups) || (0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isObject)(passageMetadataObject.groups)) {\n                passageMetadataObject.groups = [passageMetadataObject.groups];\n            }\n            for (let index = 0; index < passageMetadataObject.groups.length; index++) {\n                if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.groups[index])) {\n                    passageMetadataObject.groups[index] = {\n                        name: passageMetadataObject.groups[index],\n                        weight: 10,\n                        type: _enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__.GroupTypeEnum.Random,\n                        sequentialIndex: null,\n                        sequentialCount: null,\n                    };\n                }\n                else if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isObject)(passageMetadataObject.groups[index])) {\n                    if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.groups[index].name)) {\n                        throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'groups', index, 'name'], 'string', typeof passageMetadataObject.groups[index].name);\n                    }\n                    if (passageMetadataObject.groups[index].weight === undefined || passageMetadataObject.groups[index].weight === null) {\n                        passageMetadataObject.groups[index].weight = 10;\n                    }\n                    else if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isInteger)(passageMetadataObject.groups[index].weight)) {\n                        throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'groups', index, 'weight'], 'integer', typeof passageMetadataObject.groups[index].weight);\n                    }\n                    if (passageMetadataObject.groups[index].type === undefined || passageMetadataObject.groups[index].type === null) {\n                        passageMetadataObject.groups[index].type = _enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__.GroupTypeEnum.Random;\n                    }\n                    else if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.groups[index].type)) {\n                        throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'groups', index, 'type'], 'string', typeof passageMetadataObject.groups[index].type);\n                    }\n                    else if (passageMetadataObject.groups[index].type !== _enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__.GroupTypeEnum.Random && passageMetadataObject.groups[index].type !== _enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__.GroupTypeEnum.Sequential) {\n                        throw new _error_InvalidPassageMetadataValue__WEBPACK_IMPORTED_MODULE_1__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'groups', index, 'type'], `\"${_enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__.GroupTypeEnum.Random}\" or \"${_enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__.GroupTypeEnum.Sequential}\"`, passageMetadataObject.groups[index].type);\n                    }\n                    if (passageMetadataObject.groups[index].type === _enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__.GroupTypeEnum.Sequential) {\n                        if (passageMetadataObject.groups[index].sequentialIndex === undefined) {\n                            throw new _error_RequiredPassageMetadataValue__WEBPACK_IMPORTED_MODULE_5__[\"default\"](`groupMetadata.type = \"${_enum_GroupTypeEnum__WEBPACK_IMPORTED_MODULE_4__.GroupTypeEnum.Sequential}\"`, passageMetadataObject.passageName, ['PassageMetadata', 'groups', index, 'sequentialIndex']);\n                        }\n                        if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isInteger)(passageMetadataObject.groups[index].sequentialIndex)) {\n                            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'groups', index, 'sequentialIndex'], 'integer', typeof passageMetadataObject.groups[index].sequentialIndex);\n                        }\n                        if (passageMetadataObject.groups[index].sequentialCount === undefined || passageMetadataObject.groups[index].sequentialCount === null) {\n                            passageMetadataObject.groups[index].sequentialCount = 1;\n                        }\n                        else if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isInteger)(passageMetadataObject.groups[index].sequentialCount)) {\n                            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'groups', index, 'sequentialCount'], 'integer', typeof passageMetadataObject.groups[index].sequentialCount);\n                        }\n                    }\n                }\n                passageMetadataObject._groupByNameIndex[passageMetadataObject.groups[index].name] = index;\n            }\n        }\n        else {\n            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'groups'], 'string, object or array of strings or objects', typeof passageMetadataObject.groups);\n        }\n    }\n    processFilter(passageMetadataObject) {\n        if (passageMetadataObject.filter === undefined || passageMetadataObject.filter === null) {\n            passageMetadataObject.filter = true;\n        }\n        else if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.filter) && !(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(passageMetadataObject.filter)) {\n            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'filter'], 'string or boolean', typeof passageMetadataObject.filter);\n        }\n    }\n    processType(passageMetadataObject) {\n        if (passageMetadataObject.type === undefined || passageMetadataObject.type === null) {\n            passageMetadataObject.type = _enum_Type__WEBPACK_IMPORTED_MODULE_6__.TypeEnum.Embedded;\n        }\n        else if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.type)) {\n            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'type'], 'string', typeof passageMetadataObject.type);\n        }\n        else if (passageMetadataObject.type !== _enum_Type__WEBPACK_IMPORTED_MODULE_6__.TypeEnum.Embedded && passageMetadataObject.type !== _enum_Type__WEBPACK_IMPORTED_MODULE_6__.TypeEnum.Goto) {\n            throw new _error_InvalidPassageMetadataValue__WEBPACK_IMPORTED_MODULE_1__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'type'], `\"${_enum_Type__WEBPACK_IMPORTED_MODULE_6__.TypeEnum.Embedded}\" or \"${_enum_Type__WEBPACK_IMPORTED_MODULE_6__.TypeEnum.Goto}\"`, passageMetadataObject.type);\n        }\n    }\n    processThreshold(passageMetadataObject) {\n        if (passageMetadataObject.threshold === undefined || passageMetadataObject.threshold === null) {\n            passageMetadataObject.threshold = 100;\n        }\n        else if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isNumber)(passageMetadataObject.threshold) && !(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.threshold)) {\n            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'threshold'], 'integer or string', typeof passageMetadataObject.threshold);\n        }\n        else if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isNumber)(passageMetadataObject.threshold)) {\n            if (passageMetadataObject.threshold < 0) {\n                new _error_PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('Should equal or greater than 0', passageMetadataObject.passageName, ['PassageMetadata', 'threshold']);\n            }\n            else if (passageMetadataObject.threshold > 100) {\n                new _error_PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('Should equal or less than 100', passageMetadataObject.passageName, ['PassageMetadata', 'threshold']);\n            }\n        }\n    }\n    processTags(passageMetadataObject) {\n        if (passageMetadataObject.tags === undefined || passageMetadataObject.tags === null) {\n            passageMetadataObject.tags = [];\n        }\n        else if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.tags) || (0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isArray)(passageMetadataObject.tags)) {\n            if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.tags)) {\n                passageMetadataObject.tags = [passageMetadataObject.tags];\n            }\n            for (let index = 0; index < passageMetadataObject.tags.length; index++) {\n                if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.tags[index])) {\n                    throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'tags', index], 'string', typeof passageMetadataObject.tags[index]);\n                }\n                if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isTweeScript)(passageMetadataObject.tags[index])) {\n                    passageMetadataObject._stringTags.push(passageMetadataObject.tags[index]);\n                }\n            }\n        }\n    }\n    processLimitationStrategies(passageMetadataObject) {\n        if (passageMetadataObject.limitationStrategies === undefined || passageMetadataObject.limitationStrategies === null) {\n            passageMetadataObject.limitationStrategies = [];\n        }\n        else if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isObject)(passageMetadataObject.limitationStrategies) || (0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isArray)(passageMetadataObject.limitationStrategies)) {\n            if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isObject)(passageMetadataObject.limitationStrategies)) {\n                passageMetadataObject.limitationStrategies = [passageMetadataObject.limitationStrategies];\n            }\n            for (let index = 0; index < passageMetadataObject.limitationStrategies.length; index++) {\n                if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isObject)(passageMetadataObject.limitationStrategies[index])) {\n                    throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'limitationStrategies', index], 'object', typeof passageMetadataObject.limitationStrategies[index]);\n                }\n                if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isInteger)(passageMetadataObject.limitationStrategies[index].max)) {\n                    throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'limitationStrategies', index, 'max'], 'integer', typeof passageMetadataObject.limitationStrategies[index].max);\n                }\n                if (passageMetadataObject.limitationStrategies[index].max < 0) {\n                    throw new _error_PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('Should equal or greater than 0', passageMetadataObject.passageName, ['PassageMetadata', 'limitationStrategies', index, 'max'], null, passageMetadataObject.limitationStrategies[index].max);\n                }\n                if (passageMetadataObject.limitationStrategies[index].isSeparate === undefined || passageMetadataObject.limitationStrategies[index].isSeparate === null) {\n                    passageMetadataObject.limitationStrategies[index].isSeparate = false;\n                }\n                else if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(passageMetadataObject.limitationStrategies[index].isSeparate)) {\n                    throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'limitationStrategies', index, 'isSeparate'], 'boolean', typeof passageMetadataObject.limitationStrategies[index].isSeparate);\n                }\n                if (passageMetadataObject.limitationStrategies[index].tags === undefined || passageMetadataObject.limitationStrategies[index].tags === null) {\n                    passageMetadataObject.limitationStrategies[index].tags = [];\n                }\n                else if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.limitationStrategies[index].tags) || (0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isArray)(passageMetadataObject.limitationStrategies[index].tags)) {\n                    if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.limitationStrategies[index].tags)) {\n                        passageMetadataObject.limitationStrategies[index].tags = [passageMetadataObject.limitationStrategies[index].tags];\n                    }\n                    for (let tagindex = 0; tagindex < passageMetadataObject.limitationStrategies[index].tags.length; tagindex++) {\n                        if (!(0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isString)(passageMetadataObject.limitationStrategies[index].tags[tagindex])) {\n                            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'limitationStrategies', index, 'tags', tagindex], 'string', typeof passageMetadataObject.limitationStrategies[index].tags[tagindex]);\n                        }\n                        if ((0,_tools_TypeChecker__WEBPACK_IMPORTED_MODULE_2__.isTweeScript)(passageMetadataObject.limitationStrategies[index].tags[tagindex])) {\n                            throw new _error_PassageMetadataValidationError__WEBPACK_IMPORTED_MODULE_3__[\"default\"]('Should not contain twee scripts', passageMetadataObject.passageName, ['PassageMetadata', 'limitationStrategies', index, 'tags', tagindex], 'string', typeof passageMetadataObject.limitationStrategies[index].tags[tagindex]);\n                        }\n                    }\n                }\n                if (passageMetadataObject.limitationStrategies[index].tags.length > 0) {\n                    passageMetadataObject.limitationStrategies[index]._isTagged = true;\n                    passageMetadataObject._isLimitationStrategiesTagged = true;\n                }\n                else {\n                    passageMetadataObject.limitationStrategies[index]._isTagged = false;\n                }\n            }\n        }\n        else {\n            throw new _error_InvalidPassageMetadataValueType__WEBPACK_IMPORTED_MODULE_0__[\"default\"](passageMetadataObject.passageName, ['PassageMetadata', 'limitationStrategies'], 'object or array', typeof passageMetadataObject.limitationStrategies);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/processors/RandomEventPassageMetadataProcessor.ts?");

/***/ }),

/***/ "./src/tools/TypeChecker.ts":
/*!**********************************!*\
  !*** ./src/tools/TypeChecker.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isFloat: () => (/* binding */ isFloat),\n/* harmony export */   isInteger: () => (/* binding */ isInteger),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isStringFloat: () => (/* binding */ isStringFloat),\n/* harmony export */   isStringInteger: () => (/* binding */ isStringInteger),\n/* harmony export */   isStringNumber: () => (/* binding */ isStringNumber),\n/* harmony export */   isTweeScript: () => (/* binding */ isTweeScript)\n/* harmony export */ });\nfunction isString(variable) {\n    return typeof variable === 'string' || variable instanceof String;\n}\nfunction isBoolean(variable) {\n    return typeof variable == \"boolean\" || variable instanceof Boolean;\n}\nfunction isArray(variable) {\n    return Object.prototype.toString.call(variable) === '[object Array]';\n}\nfunction isInteger(variable) {\n    return isNumber(variable) && variable % 1 === 0;\n}\nfunction isFloat(variable) {\n    return isNumber(variable) && variable % 1 !== 0;\n}\nfunction isNumber(variable) {\n    return typeof variable === 'number' && !isNaN(variable);\n}\nfunction isStringInteger(variable) {\n    return isString(variable) && !isNaN(variable) && isInteger(parseFloat(variable));\n}\nfunction isStringFloat(variable) {\n    return isString(variable) && !isNaN(variable) && isFloat(parseFloat(variable));\n}\nfunction isStringNumber(variable) {\n    return isString(variable) && !isNaN(variable) && isNumber(parseFloat(variable));\n}\nfunction isObject(variable) {\n    return typeof variable === 'object' && !Array.isArray(variable) && variable !== null;\n}\nfunction isTweeScript(variable) {\n    return isString(variable) && !(/^\\w+[\\w_\\- ]+$/.test(variable));\n}\n\n\n//# sourceURL=webpack://RandomEventAppExport/./src/tools/TypeChecker.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/RandomEventApp.ts");
/******/ 	RandomEventAppExport = __webpack_exports__;
/******/ 	
/******/ })()
;
    var RandomEventApp = RandomEventAppExport.default;

    function initialize() {
        var randomEventApp = new RandomEventApp(
            window.passageMetadataApp,
            debugLevel,
        );

        $(document).on(':passageend', function() {
            randomEventApp.releaseLock();
        });

        Config.navigation.override = (destinationPassage) => {
            if (randomEventApp.isLocked && !randomEventApp.has(destinationPassage)) {
                // if random event fired in <<button>> or <<link>>, return previous passage to normal history forward work
                return realCurrentPassage ?? passage();
            }

            return destinationPassage;
        };

        window.randomEventApp = randomEventApp;
    }

    window.addEventListener('passage-metadata-app-initialized', () => {
        initialize();
    });
    if (window.passageMetadataApp !== undefined) {
        initialize();
    }
}());
